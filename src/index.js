// Generated by LiveScript 1.3.1
(function(){
  var docopt, bb, fs, beml, jade, _, doc, getOption, o, filename, output, templateName, config, readJson, processData;
  docopt = require('docopt').docopt;
  bb = require('bluebird');
  fs = bb.promisifyAll(require('fs'));
  beml = require('beml');
  jade = require('jade');
  _ = require('underscore');
  doc = "Usage:\n    json2html-biblio-cli [-f INPUT] [-t JADE -c CONFIG] [-o HTML]\n    json2html-biblio-cli -h | --help \n\nOptions:\n    -f, --file INPUT        Optional, original biblio.json file, if missing stdin is assumed.\n    -o, --output HTML       Optional, output filename.\n    -t, --template JADE     Specify Jade template to fill with this data.\n    -c, --config CONFIG     JSON configuration file of the site (has a `baseUrl` property)";
  getOption = function(a, b, def, o){
    if (!o[a] && !o[b]) {
      return def;
    } else {
      return o[b];
    }
  };
  o = docopt(doc);
  filename = getOption('-f', '--file', '/dev/stdin', o);
  output = getOption('-o', '--output', '/dev/stdout', o);
  templateName = getOption('-t', '--template', "", o);
  config = getOption('-c', '--config', "", o);
  readJson = function(it){
    return JSON.parse(fs.readFileSync(it, 'utf-8'));
  };
  fs.readFileAsync(filename, 'utf-8').then(function(data){
    var i$, len$, p, locals, conf, template, result;
    data = JSON.parse(data);
    for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
      p = data[i$];
      processData(p);
    }
    if (templateName === "") {
      if (output === '/dev/stdout') {
        return console.log(JSON.stringify(data, 0, 4));
      } else {
        return fs.writeFileAsync(output, JSON.stringify(data, 0, 4), 'utf8').then(function(){
          return console.error("done");
        });
      }
    } else {
      locals = {
        filename: templateName,
        data: data,
        pretty: true
      };
      conf = readJson(config);
      locals = _.extend(locals, conf);
      template = fs.readFileSync(templateName, 'utf-8');
      result = jade.compile(template, locals)(locals);
      result = beml.process(result);
      if (output === '/dev/stdout') {
        return console.log(result);
      } else {
        return fs.writeFileAsync(output, result, 'utf8').then(function(){
          return console.error("done");
        });
      }
    }
  });
  processData = function(p){
    var s, n;
    p.keyword == null && (p.keyword = []);
    p.type = (function(){
      switch (false) {
      case !in$('bookc', p.keyword):
        return 'bookchapter';
      case !in$('journal', p.keyword):
        return 'journal';
      case !in$('book', p.keyword):
        return 'book';
      case !in$('conference', p.keyword):
        return 'conference';
      case !in$('techreport', p.keyword):
        return 'techreport';
      case !in$('workshop', p.keyword):
        return 'workshop';
      case !in$('patent', p.keyword):
        return 'patent';
      case !in$('techreport', p.keyword):
        return 'techreport';
      case !in$('talk', p.keyword):
        return 'talk';
      case !in$('forum', p.keyword):
        return 'talk';
      case !in$('thesis', p.keyword):
        return 'thesis';
      default:
        return 'not categorized';
      }
    }());
    if (p.type === 'journal') {
      p.booktitle = p.journal.name;
    }
    if (p.type === 'thesis') {
      p.booktitle = p.school;
    }
    if (p.type === 'techreport') {
      p.booktitle = p.institution;
    }
    if (p.type === 'patent') {
      p.booktitle = p.address + " " + p.number;
    }
    if (p.type === 'talk') {
      p.booktitle = p.address + "";
    }
    if (p.pages == null) {
      p.pages = 'â€”';
    }
    if (p['bdsk-url-1'] == null) {
      p.link = {
        url: 'vittorio.zaccaria@polimi.it'
      };
    } else {
      p.link = {
        url: p['bdsk-url-1']
      };
    }
    if (p.booktitle != null) {
      s = p.booktitle;
      n = s.indexOf(':');
      if (n !== -1) {
        s = s.substring(0, n);
        return p.smartbooktitle = s;
      } else {
        return p.smartbooktitle = s;
      }
    }
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
